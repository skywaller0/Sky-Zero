# [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)

题目的意思大致是：合并两个已经有序的数组，结果放在第一个数组中，第一个数组假设空间足够大。要求算法时间复杂度足够低。

定两个升序排列的整数向量nums1和nums2，以及它们的有效长度m和n，把nums2中的元素合并到nums1中，使得nums1仍然是升序的。代码的逻辑是，从后往前遍历两个向量，比较它们的最后一个有效元素，把较大的那个放到nums1中合适的位置，然后更新相应的指针和长度。如果nums2中还有剩余的元素，就把它们依次放到nums1中对应的位置。



```c++
#include <iostream> // 引入输入输出流的头文件
#include <vector> // 引入向量的头文件

using namespace std; // 使用标准命名空间

void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { // 定义一个函数，接受两个整数向量和它们的有效长度作为参数，无返回值
    for (int p = m + n; m > 0 && n > 0; p--) { // 定义一个指针p，从m+n开始递减，当m和n都大于0时，循环执行以下代码
        if (nums1[m-1] <= nums2[n-1]) { // 如果nums1中最后一个有效元素小于等于nums2中最后一个有效元素
            nums1[p-1] = nums2[n-1]; // 就把nums2中最后一个有效元素放到nums1中p-1的位置
            n--; // nums2的有效长度减一
        } else { // 否则，即nums1中最后一个有效元素大于nums2中最后一个有效元素
            nums1[p-1] = nums1[m-1]; // 就把nums1中最后一个有效元素放到nums1中p-1的位置
            m--; // nums1的有效长度减一
        }
    }
    for (; n > 0; n--) { // 当n大于0时，循环执行以下代码
        nums1[n-1] = nums2[n-1]; // 把nums2中剩余的有效元素放到nums1中对应的位置
    }
}

int main() { // 定义主函数
    vector<int> nums1 = {1, 2, 3, 0, 0, 0}; // 定义一个整数向量，并初始化为{1, 2, 3, 0, 0, 0}
    vector<int> nums2 = {2, 5, 6}; // 定义另一个整数向量，并初始化为{2, 5, 6}
    merge(nums1, 3, nums2, 3); // 调用merge函数，传入nums1、nums2和它们的有效长度作为参数
    for (int i = 0; i < nums1.size(); i++) { // 遍历nums1中的每个元素
        cout << nums1[i] << " "; // 输出每个元素，并在后面加上一个空格
    }
    cout << endl; // 输出一个换行符
    return 0; // 主函数返回0，表示程序正常结束
}
```
执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：8.6 MB, 在所有 C++ 提交中击败了99.72%的用户

通过测试用例：59 / 59


```go
package main // 定义包名为main

import "fmt" // 引入格式化输入输出的包

func merge(nums1 []int, m int, nums2 []int, n int) { // 定义一个函数，接受两个整数切片和它们的有效长度作为参数，无返回值
	for p := m + n; m > 0 && n > 0; p-- { // 定义一个指针p，从m+n开始递减，当m和n都大于0时，循环执行以下代码
		if nums1[m-1] <= nums2[n-1] { // 如果nums1中最后一个有效元素小于等于nums2中最后一个有效元素
			nums1[p-1] = nums2[n-1] // 就把nums2中最后一个有效元素放到nums1中p-1的位置
			n-- // nums2的有效长度减一
		} else { // 否则，即nums1中最后一个有效元素大于nums2中最后一个有效元素
			nums1[p-1] = nums1[m-1] // 就把nums1中最后一个有效元素放到nums1中p-1的位置
			m-- // nums1的有效长度减一
		}
	}
	for ; n > 0; n-- { // 当n大于0时，循环执行以下代码
		nums1[n-1] = nums2[n-1] // 把nums2中剩余的有效元素放到nums1中对应的位置
	}
}

func main() { // 定义主函数
	nums1 := []int{1, 2, 3, 0, 0, 0} // 定义一个整数切片，并初始化为{1, 2, 3, 0, 0, 0}
	nums2 := []int{1, 2, 3} // 定义另一个整数切片，并初始化为{1, 2, 3}
	merge(nums1, 3, nums2, 3) // 调用merge函数，传入nums1、nums2和它们的有效长度作为参数
	fmt.Println(nums1) // 打印nums1的内容
}
```
执行用时：4 ms, 在所有 Go 提交中击败了31.31%的用户

内存消耗：2.2 MB, 在所有 Go 提交中击败了61.72%的用户

通过测试用例：59 / 59

这题不算难，合并两个有序数组，有技巧便是，为了不大量移动元素，就要从2个数组长度之和的最后一个位置开始，依次选取两个数组中大的数，从第一个数组的尾巴开始往头放，只要循环一次以后，就生成了合并以后的数组了。

**小技巧：**
这里我们使用了++ 和--的小技巧：a++ 和++a 都是将a 加1，但是a++ 返回值为a，而++a 返回值为a+1。如果只是希望增加a 的值，而不需要返回值，则推荐使用++a，其运行速度会略快一些。