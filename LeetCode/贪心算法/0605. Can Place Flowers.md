# [605. Can Place Flowers](https://leetcode.com/problems/can-place-flowers/)

判断一个花坛数组中是否能够种下n朵花，要求相邻的两朵花不能种在相邻的位置。它的思路是从左到右遍历花坛数组，每次跳过两个位置，如果当前位置是空的，就尝试种一朵花，然后检查下一个位置是否也是空的，如果不是，就再跳过一个位置。每种一朵花，就把n减一，直到n为零或者遍历完数组。最后判断n是否为零，如果是，就返回true，否则返回false。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool canPlaceFlowers(vector<int> &flowerbed, int n) {
    int lenth = flowerbed.size();
    for (int i = 0; i < lenth && n > 0; i += 2) {
        if (flowerbed[i] == 0) {
            if (i + 1 == lenth || flowerbed[i + 1] == 0) {
                n--;
            } else {
                i++;
            }
        }
    }
    if (n == 0) {
        return true;
    }
    return false;
}

int main() {
    vector<int> flowerbed = {1, 0, 0, 0, 1};
    int n = 1;
    cout << canPlaceFlowers(flowerbed, n) << endl;
    return 0;
}
```

```go
package main

import (
	"fmt"
)

func canPlaceFlowers(flowerbed []int, n int) bool {
	lenth := len(flowerbed)
	for i := 0; i < lenth && n > 0; i += 2 {
		if flowerbed[i] == 0 {
			if i+1 == lenth || flowerbed[i+1] == 0 {
				n--
			} else {
				i++
			}
		}
	}
	if n == 0 {
		return true
	}
	return false
}

func main() {
	fmt.Println(canPlaceFlowers([]int{1, 0, 0, 0, 1}, 1))
}
```
可以种花的基本单元是 00，然后考虑边界情况：末尾的情况需要单独判断，如果末尾为 0，也可以种花。
